package 연산자_03;

public class 사칙연산자 {

	public static void main(String[] args) {

		// 사칙 연산 시 기대한 값과 결과값이 다를 수 있는 경우
		// -------------------------------------------------------------------- //
		// 1. 변수로 저장된 피연산자(= 즉, 리터럴이 아님)와 사칙연산한 후 그 값을 int형보다 작은 변수에 저장하려고 하는 경우
		byte a1 = 1;
		byte b1 = 2;
		// byte c1 = a1 * b1;    		// 컴파일 에러!
		// byte c1 = 1 * 2;     		// 정상
		// byte c1 = (byte) (a1 + b1);  // 정상


		// 기대값: byte c1 = 2;
		// 결과: 컴파일 에러 발생
		// 이유: a1, b1 모두 int형보다 작은 byte 타입이기 때문에 연산 전 int형으로 변환한 다음 연산을 하게 되는데
		//      (int) a1 * (int) b1 = (int) 2 가 됨.
		//      근데, 변수끼리의 연산이기 때문에 컴파일러가 미리 계산을 할 수 없음.
		//      그래서 int형보다 작은 타입에 저장하려고 할 때,
		//      컴파일러는 그 결과값이 byte에 다 담을 수 있을지 없을지 알 수 없음.
		//		그래서 자바에서는 '데이터 손실을 방지'하려고 컴파일 오류를 내주는 것임.
		// 해결: 명시적으로 형변환을 해줌

		// -------------------------------------------------------------------- //
		// 2. int형 끼리 연산 후, 그 결과를 long형으로 담으려는 경우
		int a2 = 1_000_000; // 1백만
		int b2 = 2_000_000; // 2백만
		long c2 = a2 * b2 ;
		System.out.println("c2 = " + c2); // c2 = -1454759936

		// 기대값: 2_000_000_000_000 (개발자 의도: 값이 크니까 long형에 담아야 겠다)
		// 결과: -1454759936
		// 이유: 결과값이 이미 int형 이기 때문에 '오버플로우'가 남. 뒤늦게 long형으로 형변환 해도 값은 똑같음.
		// 해결: a2, b2중 하나라도 연산전에 long형으로 형변환 후 연산을 해야, 결과값도 long형에 정상적으로 담김
	}

}
